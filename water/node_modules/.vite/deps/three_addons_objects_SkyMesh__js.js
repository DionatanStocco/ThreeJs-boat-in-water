import {
  Fn,
  NodeMaterial,
  acos,
  add,
  cameraPosition,
  clamp,
  cos,
  dot,
  exp,
  float,
  max$1,
  mix,
  modelViewProjection,
  mul,
  normalize,
  positionWorld,
  pow,
  smoothstep,
  sub,
  uniform,
  varying,
  varyingProperty,
  vec3,
  vec4
} from "./chunk-SAR7KE5D.js";
import {
  BackSide,
  BoxGeometry,
  Mesh,
  Vector3
} from "./chunk-3AO7Z7HT.js";

// node_modules/three/examples/jsm/objects/SkyMesh.js
var SkyMesh = class extends Mesh {
  constructor() {
    const material = new NodeMaterial();
    super(new BoxGeometry(1, 1, 1), material);
    this.turbidity = uniform(2);
    this.rayleigh = uniform(1);
    this.mieCoefficient = uniform(5e-3);
    this.mieDirectionalG = uniform(0.8);
    this.sunPosition = uniform(new Vector3());
    this.upUniform = uniform(new Vector3(0, 1, 0));
    this.isSky = true;
    const vertexNode = Fn(() => {
      const e = float(2.718281828459045);
      const totalRayleigh = vec3(5804542996261093e-21, 13562911419845635e-21, 30265902468824876e-21);
      const MieConst = vec3(18399918514433978e-2, 27798023919660528e-2, 40790479543861094e-2);
      const cutoffAngle = float(1.6110731556870734);
      const steepness = float(1.5);
      const EE = float(1e3);
      const vSunDirection = normalize(this.sunPosition);
      varyingProperty("vec3", "vSunDirection").assign(vSunDirection);
      const angle = dot(vSunDirection, this.upUniform);
      const zenithAngleCos = clamp(angle, -1, 1);
      const sunIntensity = EE.mul(max$1(0, float(1).sub(pow(e, cutoffAngle.sub(acos(zenithAngleCos)).div(steepness).negate()))));
      varyingProperty("float", "vSunE").assign(sunIntensity);
      const vSunfade = float(1).sub(clamp(float(1).sub(exp(this.sunPosition.y.div(45e4))), 0, 1));
      varyingProperty("float", "vSunfade").assign(vSunfade);
      const rayleighCoefficient = this.rayleigh.sub(float(1).mul(float(1).sub(vSunfade)));
      varyingProperty("vec3", "vBetaR").assign(totalRayleigh.mul(rayleighCoefficient));
      const c = float(0.2).mul(this.turbidity).mul(1e-17);
      const totalMie = float(0.434).mul(c).mul(MieConst);
      varyingProperty("vec3", "vBetaM").assign(totalMie.mul(this.mieCoefficient));
      const position = modelViewProjection();
      position.z.assign(position.w);
      return position;
    })();
    const fragmentNode = Fn(() => {
      const vSunDirection = varying(vec3(), "vSunDirection");
      const vSunE = varying(float(), "vSunE");
      const vSunfade = varying(float(), "vSunfade");
      const vBetaR = varying(vec3(), "vBetaR");
      const vBetaM = varying(vec3(), "vBetaM");
      const pi = float(3.141592653589793);
      const rayleighZenithLength = float(8400);
      const mieZenithLength = float(1250);
      const sunAngularDiameterCos = float(0.9999566769464484);
      const THREE_OVER_SIXTEENPI = float(0.05968310365946075);
      const ONE_OVER_FOURPI = float(0.07957747154594767);
      const direction = normalize(positionWorld.sub(cameraPosition));
      const zenithAngle = acos(max$1(0, dot(this.upUniform, direction)));
      const inverse = float(1).div(cos(zenithAngle).add(float(0.15).mul(pow(float(93.885).sub(zenithAngle.mul(180).div(pi)), -1.253))));
      const sR = rayleighZenithLength.mul(inverse);
      const sM = mieZenithLength.mul(inverse);
      const Fex = exp(mul(vBetaR, sR).add(mul(vBetaM, sM)).negate());
      const cosTheta = dot(direction, vSunDirection);
      const c = cosTheta.mul(0.5).add(0.5);
      const rPhase = THREE_OVER_SIXTEENPI.mul(float(1).add(pow(c, 2)));
      const betaRTheta = vBetaR.mul(rPhase);
      const g2 = pow(this.mieDirectionalG, 2);
      const inv = float(1).div(pow(float(1).sub(float(2).mul(this.mieDirectionalG).mul(cosTheta)).add(g2), 1.5));
      const mPhase = ONE_OVER_FOURPI.mul(float(1).sub(g2)).mul(inv);
      const betaMTheta = vBetaM.mul(mPhase);
      const Lin = pow(vSunE.mul(add(betaRTheta, betaMTheta).div(add(vBetaR, vBetaM))).mul(sub(1, Fex)), vec3(1.5));
      Lin.mulAssign(mix(vec3(1), pow(vSunE.mul(add(betaRTheta, betaMTheta).div(add(vBetaR, vBetaM))).mul(Fex), vec3(1 / 2)), clamp(pow(sub(1, dot(this.upUniform, vSunDirection)), 5), 0, 1)));
      const L0 = vec3(0.1).mul(Fex);
      const sundisk = smoothstep(sunAngularDiameterCos, sunAngularDiameterCos.add(2e-5), cosTheta);
      L0.addAssign(vSunE.mul(19e3).mul(Fex).mul(sundisk));
      const texColor = add(Lin, L0).mul(0.04).add(vec3(0, 3e-4, 75e-5));
      const retColor = pow(texColor, vec3(float(1).div(float(1.2).add(vSunfade.mul(1.2)))));
      return vec4(retColor, 1);
    })();
    material.side = BackSide;
    material.depthWrite = false;
    material.vertexNode = vertexNode;
    material.fragmentNode = fragmentNode;
  }
};
export {
  SkyMesh
};
//# sourceMappingURL=three_addons_objects_SkyMesh__js.js.map
