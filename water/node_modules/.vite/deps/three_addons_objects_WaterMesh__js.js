import {
  Fn,
  NodeMaterial,
  add,
  cameraPosition,
  div,
  dot,
  float,
  length,
  max$1,
  mix,
  mul,
  normalize,
  positionWorld,
  pow,
  reflect,
  reflector,
  sub,
  texture,
  timerLocal,
  uniform,
  vec2,
  vec3,
  vec4
} from "./chunk-SAR7KE5D.js";
import {
  Color,
  Mesh,
  Vector3
} from "./chunk-3AO7Z7HT.js";

// node_modules/three/examples/jsm/objects/WaterMesh.js
var WaterMesh = class extends Mesh {
  constructor(geometry, options) {
    const material = new NodeMaterial();
    super(geometry, material);
    this.isWater = true;
    this.resolution = options.resolution !== void 0 ? options.resolution : 0.5;
    this.waterNormals = texture(options.waterNormals);
    this.alpha = uniform(options.alpha !== void 0 ? options.alpha : 1);
    this.size = uniform(options.size !== void 0 ? options.size : 1);
    this.sunColor = uniform(new Color(options.sunColor !== void 0 ? options.sunColor : 16777215));
    this.sunDirection = uniform(options.sunDirection !== void 0 ? options.sunDirection : new Vector3(0.70707, 0.70707, 0));
    this.waterColor = uniform(new Color(options.waterColor !== void 0 ? options.waterColor : 8355711));
    this.distortionScale = uniform(options.distortionScale !== void 0 ? options.distortionScale : 20);
    const timeNode = timerLocal();
    const getNoise = Fn(([uv]) => {
      const uv0 = add(div(uv, 103), vec2(div(timeNode, 17), div(timeNode, 29))).toVar();
      const uv1 = div(uv, 107).sub(vec2(div(timeNode, -19), div(timeNode, 31))).toVar();
      const uv2 = add(div(uv, vec2(8907, 9803)), vec2(div(timeNode, 101), div(timeNode, 97))).toVar();
      const uv3 = sub(div(uv, vec2(1091, 1027)), vec2(div(timeNode, 109), div(timeNode, -113))).toVar();
      const sample0 = this.waterNormals.uv(uv0);
      const sample1 = this.waterNormals.uv(uv1);
      const sample2 = this.waterNormals.uv(uv2);
      const sample3 = this.waterNormals.uv(uv3);
      const noise = sample0.add(sample1).add(sample2).add(sample3);
      return noise.mul(0.5).sub(1);
    });
    const fragmentNode = Fn(() => {
      const noise = getNoise(positionWorld.xz.mul(this.size));
      const surfaceNormal = normalize(noise.xzy.mul(1.5, 1, 1.5));
      const diffuseLight = vec3(0).toVar();
      const specularLight = vec3(0).toVar();
      const worldToEye = cameraPosition.sub(positionWorld);
      const eyeDirection = normalize(worldToEye);
      const reflection = normalize(reflect(this.sunDirection.negate(), surfaceNormal));
      const direction = max$1(0, dot(eyeDirection, reflection));
      specularLight.addAssign(pow(direction, 100).mul(this.sunColor).mul(2));
      diffuseLight.addAssign(max$1(dot(this.sunDirection, surfaceNormal), 0).mul(this.sunColor).mul(0.5));
      const distance = length(worldToEye);
      const distortion = surfaceNormal.xy.mul(float(1e-3).add(float(1).div(distance))).mul(this.distortionScale);
      const mirrorSampler = reflector();
      mirrorSampler.uvNode = mirrorSampler.uvNode.add(distortion);
      mirrorSampler.resolution = this.resolution;
      this.add(mirrorSampler.target);
      const theta = max$1(dot(eyeDirection, surfaceNormal), 0);
      const rf0 = float(0.3);
      const reflectance = mul(pow(float(1).sub(theta), 5), float(1).sub(rf0)).add(rf0);
      const scatter = max$1(0, dot(surfaceNormal, eyeDirection)).mul(this.waterColor);
      const albedo = mix(this.sunColor.mul(diffuseLight).mul(0.3).add(scatter), mirrorSampler.rgb.mul(specularLight).add(mirrorSampler.rgb.mul(0.9)).add(vec3(0.1)), reflectance);
      return vec4(albedo, this.alpha);
    })();
    material.fragmentNode = fragmentNode;
  }
};
export {
  WaterMesh
};
//# sourceMappingURL=three_addons_objects_WaterMesh__js.js.map
